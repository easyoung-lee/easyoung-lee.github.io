---
layout: single
title:  "[Algorithm] BFS - '미로 탈출 문제'" 
categories: Algorithm
comments: true
author_profile: true
sidebar:
  nav: "docs"
tags: [Algorithm, Algorithm etc, Python]
toc: true
toc_sticky: true
toc_label: "About This Page"
toc_icon: "sticky-note"

---

📣 학습한 내용을 정리한 글입니다. <br>
<br>
**BFS 알고리즘** 문제입니다. 문제에 대한 내용과 풀이 그리고 결과를 간단하게 작성하였으니 참고바랍니다.  
풀이 언어 : Python
{: .notice--warning}

# 문제 설명

---

<br>
<b><u><span style="font-size:20px">내용</span></u></b>

영준이는 N x M 크기의 직사각형 형태의 미로에 갇혔다. 영준이의 위치는 (1, 1)이며, 미로의 출구는 (N, M)이다.  
이때 괴물이 있는 부분은 '0'이고 괴물이 없는 부분은 '1'이다. 이때 영준이가 탈출하기 위해 움직여야하는 최소 칸의 개수는?  
(단 칸을 셀 때는 시작 칸과 마지막 칸을 모두 포함해서 계산한다.)

<br>
<b><u><span style="font-size:20px">입력</span></u></b>

첫 번째 줄에 두 정수 N, M이 입력된다. (4 <= N, M <= 200)  
두 번째 줄부터 N+1개 줄 까지 각각 M개의 정수(0 or 1)의 미로 정보가 입력된다.  
(각각 수들은 공백없이 입력되며, 시작 칸과 마지막 칸은 항상 1이다.)

<br>
<b><u><span style="font-size:20px">출력</span></u></b>

첫째 줄에 이동 칸의 개수를 출력한다.

<br>
<br>

# 문제 풀이

---

**Implementation Algorithm 참고내용**
- DFS는 깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다.<br>
- 스택 자료구조(혹은 재귀 함수)를 이용한다.<br>

위 참고사항을 준수하며, 풀어보자.<br>
특정한 지점의 주변 상, 하, 좌, 우를 살펴본 뒤 주변 지점 중에서 값이 '0'이면서 아직 방문하지 않은 지점을 찾는다.  
이를 반복하면 연결된 모든 지점을 방문할 수 있으며, '1'이 아닌 '0'의 값을 찾을 수 있고 연결되어있는 지점을 분할시켜 카운트하면 결과 값을 구할 수 있다.

<br>
<br>

# 작성 코드

## Python

<br>
<b><u><span style="font-size:20px">DFS 알고리즘</span></u></b>
<script src="https://gist.github.com/easyoung-lee/8333270bb6aab67b6adf610c66952a0c.js"></script>


<br>
<b><u><span style="font-size:20px">BFS 알고리즘</span></u></b>
<script src="https://gist.github.com/easyoung-lee/a34eba079108d7576bb2af50af5cf96f.js"></script>


<br>
<br>

---
[참고 : '동빈나'님의 (이코테 2021 강의 몰아보기) 3. DFS & BFS 영상](https://www.youtube.com/watch?v=7C9RgOcvkvo&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=3)

---
